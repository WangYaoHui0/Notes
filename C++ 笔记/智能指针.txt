1.为什么需要智能指针？
	（1）如果malloc出来的空间，没有进行释放，存在内存泄露的问题，
	（2）异常安全问题。如果在malloc和free之间存在抛异常，那么还是会有内存泄露。类似这种问题就是异常安全。

2.智能指针的使用及原理
	（1）RAII：
		- RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件
			句柄、网络连接、互斥量等等）的简单技术。

		- 在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的
			时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。
		- 这种做法有两大好处：
			- 不需要显示地释放资源，
			- 采用这种方式，对象所需的资源在其生命期内始终保持有效。

	（2）智能指针的原理：
		- RAII特性，
		- 重载 operator* 和 operator->，具有像指针一样的行为。

	（3）std::auto_ptr：
		- C++98版本的库中就提供了auto_ptr的智能指针。
		- auto_ptr的问题：当对象拷贝或者赋值后，前面的对象就悬空了。
		- auto_ptr的实现原理：管理权转移的思想。
			- 即一旦发生拷贝，就将ap中资源转移到当前对象中，然后令ap与其所管理资源断开联系，
				这样就解决了一块空间被多个对象使用而造成程序奔溃问题。

	（4）std::unique_ptr：
		- C++11中开始提供更靠谱的unique_ptr，
		- unique_ptr的实现原理：简单粗暴的防拷贝，不让拷贝和赋值。

	（5）std::shared_ptr：
		- C++11中开始提供更靠谱的并且支持拷贝的shared_ptr，
		- shared_ptr的原理：是通过引用计数的方式来实现多个shared_ptr对象之间共享资源。例如：老师晚
			上在下班之前都会通知，让最后走的学生记得把门锁下。

		- shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共享。
		- 在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一。
		- 如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；
		- 如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。

		- std::shared_ptr的线程安全问题：
			- 需要注意的是shared_ptr的线程安全分为两方面：
				- 智能指针对象中引用计数是多个智能指针对象共享的，两个线程中智能指针的引用计数
					同时++或--，这个操作不是原子的，引用计数原来是1，++了两次，可能还是2，
					这样引用计数就错乱了。会导致资源未释放或者程序崩溃的问题。所以智能指针中
					引用计数++、--是需要加锁的，也就是说引用计数的操作是线程安全的。

				- 智能指针管理的对象存放在堆上，在两个线程中同时去访问，会导致线程安全问题。

		- std::shared_ptr的循环引用问题：
			- node1和node2两个智能指针对象指向两个节点，引用计数变成1，我们不需要手动delete。
			- node1的_next指向node2，node2的_prev指向node1，引用计数变成2。
			- node1和node2析构，引用计数减到1，但是_next还指向下一个节点，_prev还指向上一个节点。
			- 也就是说_next析构了，node2就释放了，
			- 也就是是_prev析构了，node1就释放了，
			- 但是_next属于node1的成员，node1释放了，_next才会析构，而node1由_prev管理，_prev属于node2
				成员，所以这就叫循环引用，谁也不会释放。

			- 解决循环引用问题的方法：
				- 在引用计数的场景下，把节点中的_prev和_next改成weak_ptr，
				- 原理：node1->_next = node2 和 node2->_prev = node1 时weak_ptr的_next和_prev
					不会增加node1和node2的引用计数。

			- 如果不是new出来的对象如何通过智能指针管理？
				- shared_ptr设计了一个删除器来解决这个问题。

3.C++11和boost中的智能指针关系
	（1）C++98中产生了第一个智能指针auto_ptr。
	（2）C++ boost给出了更实用的 scoped_ptr、shared_ptr、weak_ptr。
	（3）C++ TR1，引入了shared_ptr等。不过需要注意，TR1并不是标准版。
	（4）C++ 11，引入了unique_ptr、shared_ptr、weak_ptr。需要注意的是：unique_ptr对应于boost的scoped_ptr。
		并且这些智能指针的实现原理是参考boost中的实现的。

4.RAII
	（1）RAII思想除了可以用来设计智能指针，还可以用来设计守卫锁，防止异常安全导致的死锁问题。

5.问：为什么需要智能指针？
	- 答：	- 因为如果malloc/new出来的空间没有free/delete，就会导致内存泄露的问题，亦或者在malloc/free、
			new/delete之间存在抛异常，也会导致内存泄露，因此引入智能指针可以很好的管理资源，相当于
			将管理资源的任务托管给了一个对象，在对象析构时会释放资源。
		- 智能指针是一种预防性的内存泄露的解决方案，在C++没有垃圾回收器的环境下，可以很好的
			解决异常安全等带来的内存泄露问题。



