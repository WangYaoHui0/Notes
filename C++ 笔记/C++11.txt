1.列表初始化
	（1）C++98中{}的初始化问题：
		- C++98 中{}对内置类型可以，但对于一些自定义的类型，无法使用。
		- C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定
			义的类型，使用初始化列表时，可添加等号(=)，也可不添加。

	（2）自定义类型的列表初始化：
		- 标准库支持单个对象的列表初始化，

		- 多个对象想要支持列表初始化，需给该类(模板类)添加一个带有initializer_list类型参数的构造函数即可。
			- 注意：initializer_list是系统自定义的类模板，该类模板中主要有三个方法：begin()、end()迭代器
				以及获取区间中元素个数的方法size()。

	（3）使用列表初始化优点：
		- 简单方便
		- 放置类型变窄

2.变量类型推导
	（1）auto使用的前提是：必须要对auto声明的类型进行初始化，否则编译器无法推导出auto的实际类型。

	（2）但有时候可能需要根据表达式运行完成之后结果的类型进行推导，因为编译期间，代码不会运行，此时
		auto也就无能为力。如果能用加完之后结果的实际类型作为函数的返回值类型就不会出错，但这需要
		程序运行完才能知道结果的实际类型，即RTTI(Run-Time Type Identification 运行时类型识别)。
		C++98中确实已经支持RTTI：
			- typeid只能查看类型不能用其结果类定义类型
			- dynamic_cast只能应用于含有虚函数的继承体系中

		- 运行时类型识别的缺陷是降低程序运行的效率。

	（3）decltype类型推导：
		- decltype是根据表达式的实际类型推演出定义变量时所用的类型。
			- 推演表达式类型作为变量的定义类型
			- 推演匿名类型对象
			- 推演函数的类型

	（4）decltype推导的四个规则：
		- 如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e所命名的实体的
			类型。如果e是一个被重载的函数，则会编译失败，
			- 标记符表达式：单个标记符对应的表达式即为标记符表达式。
			(除去关键字、字面常量等编译器需要用到的标记)比如：int arr[3]；arr为标记符表达式，
				但是arr[0] + 3和arr[3]就不是。

		- 否则，假设e的类型是T，如果e是将亡值(比如临时变量或者函数局部变量)，decltype(e)被推导为T&&，

		- 否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T的引用，

		- 否则，假设e的类型是T，则decltype(e)为T。

	（5）返回值类型追踪：
		- 把函数的返回值移至参数声明之后，复合符号->decltype(left+right)被称为：追踪返回类型。原本函数
			返回值位置由auto占据，这样就可让编译器来推导函数的返回值类型了。

3.基于范围的for循环

4.final与override

5.委派构造函数
	（1）构造函数冗余造成重复：
		- 委派构造函数也是C++11中对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间。
			通过委派其他构造函数，多构造函数的类编写更加容易。

	（2）委派构造函数：
		- 所谓委派构造函数：就是指委派函数将构造的任务委派给目标构造函数来完成的一种类构造的方式。

		- 在初始化列表中调用”基准版本”的构造函数称为委派构造函数，而被调用的”基准版本”则称为目标构造函数。

		- 注：构造函数不能同时“委派”和使用初始化列表

	（3）环状委托问题：
		- 构造函数较多的时候，可能不止一个委派构造函数，一些目标函数很可能也是委派构造函数。

		- 注：如果有多个委派构造函数，不能形成环状委托。

	（4）使用构造模板函数产生目标函数：
		- 定义一个模板构造函数，通过多个委派构造函数的委托，构造函数模板会被实例化，这样A类就可以很容易
			地接受各种容器对其进行初始化。

6.默认函数控制
	对于默认的成员函数，如果在类中显式定义了，编译器将不会重新生成默认版本。有时候这样的规则可能被忘记，
		最常见的是声明了带参数的构造函数，必要时则需要定义不带参数的版本以实例化无参的对象。而且有时
		编译器会生成，有时又不生成，容易造成混乱，于是C++11让程序员可以控制是否需要编译器生成。

	（1）显示缺省函数：
		- 在C++11中，可以在默认函数定义或者声明时加上=default，从而显式的指示编译器生成该函数的默认版本，
			用=default修饰的函数称为显式缺省函数。

	（2）删除默认函数：
		- 如果想要限制某些默认函数的生成，在C++98中，是将该函数设置成private，并且不给定义，这样只要其他人
			想要调用就会报错。在C++11中更简单，只需在该函数声明后加上=delete即可，该语法指示编译器不
			生成对应函数的默认版本，称=delete修饰的函数为删除函数。

		- 删除函数也可以避免编译器做一些不必要的隐式类型转化

		- 注：避免删除函数和explicit一起使用

7.右值引用
	（1）移动语义：
		- 将一个对象中资源移动到另一个对象中的方式，称之为移动语义。在C++11中如果需要实现移动语义，必须
			使用右值引用。

	（2）C++11中的右值：
		- 右值引用：即对右值的引用。C++11中，右值有两个概念组成：纯右值和将亡值。

		- 纯右值：
			- 纯右值是C++98中右值的概念，用于识别临时变量和一些不跟对象关联的值。比如：常量、一些
				运算表达式(1+3)等。

		- 将亡值：
			- 生命周期将要结束的对象。比如：在值返回时的临时对象。

	（3）右值引用：
		- 与移动语义结合，减少不必要资源的开辟，来提高代码的运行效率。

		- 给一个匿名对象取别名，延长匿名对象的生命周期。

		- 注：
			- 与引用一样，右值引用在定义时必须初始化。
			- 通常情况下，右值引用不能引用左值。

	（4）std::move()：
		- C++11中，std::move()函数位于头文件中，这个函数名字具有迷惑性，它并不搬移任何东西，唯一的功能
			就是将一个左值强制转化为右值引用，通过右值引用使用该值，实现移动语义。
		- 注：被转化的左值，其生命周期并没有随着左右值的转化而改变，即std::move转化的左值变量value不会被销毁。

		- 注：为了保证移动语义的传递，程序员在编写移动构造函数时，最好使用std::move将拥有资源的成员
			强转为右值引用。

	（5）移动语义中的一些问题：
		- 如果将移动构造函数声明为常右值引用或者返回右值的函数声明为常量，都会导致移动语义无法实现。
			- String(const String&&);
			- const Person GetTempPerson();

		- 在C++11中，拷贝/移动构造函数实际上有3个版本：
			- Object(T&)
			- Object(const T&)
			- Object(T&&)

		- C++11中默认成员函数：
			- 常量左值引用的版本是拷贝构造函数版本，右值引用版本是移动构造版本。
			- 默认情况下，编译器会为程序员隐式生成一个(如果没有用到则不会生成)移动构造函数。
			- 如果程序员声明了自定义的拷贝构造函数、拷贝赋值函数、移动赋值函数、析构函数中的
				一个或者多个，编译器都不会再为程序员生成默认版本。
			- 编译器生成的默认移动构造函数实际和默认的拷贝构造函数类似，都是按照位拷贝(即浅拷贝)
				来进行的。因此，在类中涉及到资源管理时，程序员最好自己定义移动构造函数。
			- 在C++11中，拷贝构造/移动构造/赋值/移动赋值函数必须同时提供，或者同时不提供，
				程序才能保证类同时具有拷贝和移动语义。

	（6）完美转发：
		- 完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。

		- 函数模板在向其他函数传递自身形参时，如果相应实参是左值，它就应该被转发为左值；同样如果相应实参是
			右值，它就应该被转发为右值。这样做是为了保留在其他函数针对转发而来的参数的左右值属性进行不同
			处理（比如参数为左值时实施拷贝语义；参数为右值时实施移动语义）的可能性。

		- C++11通过forward函数来实现完美转发

8.lambda表达式
	（1）lambda表达式语法：
		- lambda表达式书写格式：[capture-list] (parameters) mutable ->return-type { statement }
			- lambda表达式各部分说明：
				- [capture-list]：捕捉列表，该列表总是出现在lambda函数的开始位置，编译器根据[]
					来判断接下来的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供
					lambda函数使用；

				- (parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以
					连同()一起省略；

				- mutable：默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性。
					使用该修饰符时，参数列表不可省略(即使参数为空)；

				- ->return-type：返回值类型，用追踪返回类型形式声明函数的返回值类型，没有返回值
					时此部分可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导；

				- {statement}：函数体，在该函数体内，除了可以使用其参数外，还可以使用所有捕获到的变量。

			- 注：
				- 在lambda函数定义中，参数列表和返回值类型都是可选部分，而捕捉列表和函数体可以为空。
					因此C++11中最简单的lambda函数为：[]{}; 该lambda函数不能做任何事情。

		- lambda表达式实际上可以理解为无名函数，该函数无法直接调用，如果想要直接调用，可借助auto将其赋值
			给一个变量。

		- 捕获列表说明：
			- 捕捉列表描述了上下文中哪些数据可以被lambda使用，以及使用的方式传值还是传引用。
				- [var]：表示值传递方式捕捉变量var
				- [=]：表示值传递方式捕获所有父作用域中的变量(包括this)
				- [&var]：表示引用传递捕捉变量var
				- [&]：表示引用传递捕捉所有父作用域中的变量(包括this)
				- [this]：表示值传递方式捕捉当前的this指针

			- 注：
				- a.父作用域指包含lambda函数的语句块
				- b.语法上捕捉列表可由多个捕捉项组成，并以逗号分割。
					比如：[=, &a, &b]：以引用传递的方式捕捉变量a和b，值传递方式捕捉其他所有变量
						[&，a, this]：值传递方式捕捉变量a和this，引用方式捕捉其他变量c。捕捉
						列表不允许变量重复传递，否则就会导致编译错误。比如：[=, a]：=已经以
						值传递方式捕捉了所有变量，捕捉a重复
				- d.在块作用域以外的lambda函数捕捉列表必须为空。
				- e.在块作用域中的lambda函数仅能捕捉父作用域中局部变量，捕捉任何非此作用域或者非局部
					变量都会导致编译报错。
				- f.lambda表达式之间不能相互赋值，即使看起来类型相同

	（2）函数对象与lambda表达式：
		- 函数对象，又称为仿函数，即可以像函数一样使用的对象，就是在类中重载了operator()运算符的类对象。

		- 从使用方式上来看，函数对象与lambda表达式完全一样。

		- 函数对象将rate作为其成员变量，在定义对象时给出初始值即可，lambda表达式通过捕获列表可以直接将该
			变量捕获到。

		- 实际在底层，编译器对于lambda表达式的处理方式，完全就是按照函数对象的方式处理的，即：如果定义了一
			个lambda表达式，编译器会自动生成一个类，在该类中重载了operator()。

9.线程库
	（1）线程的启动：
		- C++线程库通过构造一个线程对象来启动一个线程，该线程对象中就包含了线程运行时的上下文环境，比如：
			线程函数、线程栈、线程起始状态等以及线程ID等，所有操作全部封装在一起，最后在底层统一传递给
			_beginthreadex() 创建线程函数来实现(注意：_beginthreadex是windows中创建线程的底层c函数)。

		- std::thread()创建一个新的线程可以接受任意的可调用对象类型（带参数或者不带参数），包括lambda表达
			式（带变量捕获或者不带），函数，函数对象，以及函数指针。

	（2）线程的结束：
		- 加入式：join()
			- join()：会主动地等待线程的终止。在调用进程中join()，当新的线程终止时，join()会清理相关的
				资源，然后返回，调用线程再继续向下执行。由于join()清理了线程的相关资源，thread对象
				与已销毁的线程就没有关系了，因此一个线程的对象每次你只能使用一次join()，当你调用了
				join()之后joinable()就将返回false了。

		- 分离式：detach()
			- detach：会从调用线程中分理出新的线程，之后不能再与新线程交互。就像是你和你女朋友分手，那
				之后你们就不会再有联系（交互）了，而她的之后消费的各种资源也就不需要你去埋单了（清理资
				源）。此时调用joinable()必然是返回false。分离的线程会在后台运行，其所有权和控制权将会
				交给c++运行库。同时，C++运行库保证，当线程退出时，其相关资源的能够正确的回收。

		- 注意：
			- 必须在thread对象销毁之前做出选择，这是因为线程可能在你加入或分离线程之前，就已经结束了，
				之后如果再去分离它，线程可能会在thread对象销毁之后继续运行下去。

	（3）原子性操作库（atomic）：
		- 多线程最主要的问题是共享数据带来的问题(即线程安全)。

		- C++98中传统的解决方式：可以对共享修改的数据可以加锁保护。

		- 虽然加锁可以解决，但是加锁有一个缺陷就是：只要一个线程在对sum++时，其他线程就会被阻塞，会影响
			程序运行的效率，而且锁如果控制不好，还容易造成死锁。因此C++11中引入了原子操作。

		- 注意：需要使用原子操作变量时，必须添加头文件






