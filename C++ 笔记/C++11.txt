1.列表初始化
	（1）C++98中{}的初始化问题：
		- C++98 中{}对内置类型可以，但对于一些自定义的类型，无法使用。
		- C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定
			义的类型，使用初始化列表时，可添加等号(=)，也可不添加。

	（2）自定义类型的列表初始化：
		- 标准库支持单个对象的列表初始化，

		- 多个对象想要支持列表初始化，需给该类(模板类)添加一个带有initializer_list类型参数的构造函数即可。
			- 注意：initializer_list是系统自定义的类模板，该类模板中主要有三个方法：begin()、end()迭代器
				以及获取区间中元素个数的方法size()。

	（3）使用列表初始化优点：
		- 简单方便
		- 放置类型变窄

2.变量类型推导
	（1）auto使用的前提是：必须要对auto声明的类型进行初始化，否则编译器无法推导出auto的实际类型。

	（2）但有时候可能需要根据表达式运行完成之后结果的类型进行推导，因为编译期间，代码不会运行，此时
		auto也就无能为力。如果能用加完之后结果的实际类型作为函数的返回值类型就不会出错，但这需要
		程序运行完才能知道结果的实际类型，即RTTI(Run-Time Type Identification 运行时类型识别)。
		C++98中确实已经支持RTTI：
			- typeid只能查看类型不能用其结果类定义类型
			- dynamic_cast只能应用于含有虚函数的继承体系中

		- 运行时类型识别的缺陷是降低程序运行的效率。

	（3）decltype类型推导：
		- decltype是根据表达式的实际类型推演出定义变量时所用的类型。
			- 推演表达式类型作为变量的定义类型
			- 推演匿名类型对象
			- 推演函数的类型

	（4）decltype推导的四个规则：
		- 如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e所命名的实体的
			类型。如果e是一个被重载的函数，则会编译失败，
			- 标记符表达式：单个标记符对应的表达式即为标记符表达式。
			(除去关键字、字面常量等编译器需要用到的标记)比如：int arr[3]；arr为标记符表达式，
				但是arr[0] + 3和arr[3]就不是。

		- 否则，假设e的类型是T，如果e是将亡值(比如临时变量或者函数局部变量)，decltype(e)被推导为T&&，

		- 否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T的引用，

		- 否则，假设e的类型是T，则decltype(e)为T。

	（5）返回值类型追踪：
		- 把函数的返回值移至参数声明之后，复合符号->decltype(left+right)被称为：追踪返回类型。原本函数
			返回值位置由auto占据，这样就可让编译器来推导函数的返回值类型了。

3.基于范围的for循环

4.final与override

5.委派构造函数
	（1）构造函数冗余造成重复：
		- 委派构造函数也是C++11中对C++的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间。
			通过委派其他构造函数，多构造函数的类编写更加容易。

	（2）委派构造函数：
		- 所谓委派构造函数：就是指委派函数将构造的任务委派给目标构造函数来完成的一种类构造的方式。

		- 在初始化列表中调用”基准版本”的构造函数称为委派构造函数，而被调用的”基准版本”则称为目标构造函数。

		- 注：构造函数不能同时“委派”和使用初始化列表

	（3）环状委托问题：
		- 构造函数较多的时候，可能不止一个委派构造函数，一些目标函数很可能也是委派构造函数。

		- 注：如果有多个委派构造函数，不能形成环状委托。

	（4）使用构造模板函数产生目标函数：
		- 定义一个模板构造函数，通过多个委派构造函数的委托，构造函数模板会被实例化，这样A类就可以很容易
			地接受各种容器对其进行初始化。

6.默认函数控制
	对于默认的成员函数，如果在类中显式定义了，编译器将不会重新生成默认版本。有时候这样的规则可能被忘记，
		最常见的是声明了带参数的构造函数，必要时则需要定义不带参数的版本以实例化无参的对象。而且有时
		编译器会生成，有时又不生成，容易造成混乱，于是C++11让程序员可以控制是否需要编译器生成。

	（1）显示缺省函数：
		- 在C++11中，可以在默认函数定义或者声明时加上=default，从而显式的指示编译器生成该函数的默认版本，
			用=default修饰的函数称为显式缺省函数。

	（2）删除默认函数：
		- 如果想要限制某些默认函数的生成，在C++98中，是将该函数设置成private，并且不给定义，这样只要其他人
			想要调用就会报错。在C++11中更简单，只需在该函数声明后加上=delete即可，该语法指示编译器不
			生成对应函数的默认版本，称=delete修饰的函数为删除函数。

		- 删除函数也可以避免编译器做一些不必要的隐式类型转化

		- 注：避免删除函数和explicit一起使用

7.右值引用
	（1）移动语义：
		- 将一个对象中资源移动到另一个对象中的方式，称之为移动语义。在C++11中如果需要实现移动语义，必须
			使用右值引用。

	（2）C++11中的右值：
		- 右值引用：即对右值的引用。C++11中，右值有两个概念组成：纯右值和将亡值。

		- 纯右值：
			- 纯右值是C++98中右值的概念，用于识别临时变量和一些不跟对象关联的值。比如：常量、一些
				运算表达式(1+3)等。

		- 将亡值：
			- 生命周期将要结束的对象。比如：在值返回时的临时对象。

	（3）右值引用：
		- 与移动语义结合，减少不必要资源的开辟，来提高代码的运行效率。

		- 给一个匿名对象取别名，延长匿名对象的生命周期。

		- 注：
			- 与引用一样，右值引用在定义时必须初始化。
			- 通常情况下，右值引用不能引用左值。

	（4）std::move()：
		- C++11中，std::move()函数位于头文件中，这个函数名字具有迷惑性，它并不搬移任何东西，唯一的功能
			就是将一个左值强制转化为右值引用，通过右值引用使用该值，实现移动语义。
		- 注：被转化的左值，其生命周期并没有随着左右值的转化而改变，即std::move转化的左值变量value不会被销毁。

		- 注：为了保证移动语义的传递，程序员在编写移动构造函数时，最好使用std::move将拥有资源的成员
			强转为右值引用。

	（5）移动语义中的一些问题：
		- 如果将移动构造函数声明为常右值引用或者返回右值的函数声明为常量，都会导致移动语义无法实现。
			- String(const String&&);
			- const Person GetTempPerson();

		- 在C++11中，拷贝/移动构造函数实际上有3个版本：
			- Object(T&)
			- Object(const T&)
			- Object(T&&)

		- C++11中默认成员函数：
			- 常量左值引用的版本是拷贝构造函数版本，右值引用版本是移动构造版本。
			- 默认情况下，编译器会为程序员隐式生成一个(如果没有用到则不会生成)移动构造函数。
			- 如果程序员声明了自定义的拷贝构造函数、拷贝赋值函数、移动赋值函数、析构函数中的
				一个或者多个，编译器都不会再为程序员生成默认版本。
			- 编译器生成的默认移动构造函数实际和默认的拷贝构造函数类似，都是按照位拷贝(即浅拷贝)
				来进行的。因此，在类中涉及到资源管理时，程序员最好自己定义移动构造函数。
			- 在C++11中，拷贝构造/移动构造/赋值/移动赋值函数必须同时提供，或者同时不提供，
				程序才能保证类同时具有拷贝和移动语义。

	（6）完美转发：
		- 完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。


























