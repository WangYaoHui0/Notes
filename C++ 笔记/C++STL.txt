1.STL本质
	（1）高效的C++程序库，采用泛型编程思想对常见数据结构和算法等进行封装。
	（2）STL中包含了：容器、适配器、算法、迭代器、仿函数、空间配置器。

2.STL的六大组件
	（1）容器

	（2）算法

	（3）迭代器：
		- 迭代器是一种设计模式，让用户通过特定的接口访问容器的数据，不需要了解容器内部的底层数据结构。
		- C++中迭代器本质：是一个指针，让该指针按照具体的结构去操作容器中的数据。

		- 每个容器的底层结构都不同，为了降低算法使用容器时的复杂度，底层结构应该对于算法透明，迭代器就充
			当了算法与容器之间的转接层。
		- 因此：每个容器的迭代器应该由容器设计者负责提供，然后容器按照约定给出统一的接口即可。

		- 迭代器实现原理：
			- vector：
				- 因为vector底层结构为一段连续空间，迭代器前后移动时比较容易实现，因此vector的
					迭代器实际是对原生态指针的封装，即：typedef T* iterator。

			- list：
				- list底层结构为带头结点的双向循环链表，迭代器在移动时，只能按照链表的结构前后
					依次移动，因此链表的迭代器需要对原生态的指针进行封装，因为当对迭代器++时，
					应该通过节点中的next指针域找到下一个节点。

				- 如果迭代器不能直接使用原生态指针操作底层数据时，必须要对指针进行封装，在封装时
					需要提供以下方法：
					- 迭代器能够像指针一样方式进行使用：
						- 重载pointer operator*() / reference operator->()

					- 能够让迭代器移动：
						- 向后移动：self& operator++() / self operator++(int)
						- 向前移动：self& operator--() / self operator--(int)
							(注意：有些容器不能向前移动，比如forward_list)

					- 支持比较-因为在遍历时需要知道是否移动到区间的末尾：
							- bool operator!=(const self& it)const
							- bool operator==(const self& it)const

		- 迭代器与类的融合：
			- 定义迭代器类，
			- 在容器类中统一迭代器名字，例如：typedef __list_iterator<T, T&, T*> iterator;
			- 在容器类中添加获取迭代器范围的接口。	// begin()/end()

		- 反向迭代器：
			- 反向迭代器：正向迭代器的适配器，即正向迭代器++往end方向移动，--往begin方向移动，
				而反向迭代器++则往begin方向移动，--则向end方向移动。

		- 迭代器萃取

	（4）适配器：
		- 将一个类的接口转换成用户希望的另一个类的接口，使原本接口不兼容的类可以一起工作。

		- STL中适配器总共有三种类型：
			- 容器适配器：stack和queue。
				- stack的特性是后进先出，queue的特性为先进先出，该种特性deque的接口完全
					满足，因此stack和queue在底层将deque容器中的接口进行了封装。

			- 迭代器适配器：反向迭代器。
				- 反向迭代器++和--操作刚好和正向迭代器相反，因此：反向迭代器只需将正向
					迭代器进行重新封装即可。

			- 函数适配器

	（5）仿函数：
		- 仿函数：一种具有函数特征的对象，调用者可以像函数一样使用该对象 ，为了能够“行为类似函数”，
			该对象所在类必须自定义函数调用运算符operator()，重载该运算符后，就可在仿函数对象的
			后面加上一对小括号，以此调用仿函数所定义的operator()操作。

		- 作用：
			- 提高算法的灵活性。

	（6）空间配置器



