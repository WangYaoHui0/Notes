1.继承的概念及定义
	（1）概念：
		- 继承机制是面向对象编程中，使代码可以复用的重要手段，
		- 允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类，
		- 继承体现了面向对象编程的层次结构，
		- 继承是类设计层次的复用，
		- 继承后父类的成员（成员函数+成员变量）都会变成子类的一部分。

	（2）定义：
		- 继承后，基类成员在派生类中访问方式的变化：

		类成员\继承方式		public继承		protected继承		private继承

		基类的public成员	派生类的public成员	派生类的protected成员	派生类的private成员

		基类的protected成员	派生类的protected成员	派生类的protected成员	派生类的private成员

		基类的private成员	在派生类中不可见	在派生类中不可见	在派生类中不可见

		- 总结：
			- 基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有
				成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面
				都不能去访问它。

			- 基类private成员在派生类中是不能被访问的，如果基类成员不想在类外直接被访问，但需要在
				派生类中能访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。

			- 对上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在
				子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public > protected > private。

			- 使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过
				最好显示的写出继承方式。

			- 在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承，也不提倡使用
				protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，
				实际中扩展维护性不强。

	（3）继承和组合：
		- public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象。

		- 组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。

		- 优先使用对象组合，而不是类继承。

		- 继承允许你根据基类类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用
			(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见。
			继承一定程度破坏了基类的封装，基类的改变，对派生类类有很大的影响。派生类和基类间的依赖
			关系很强，耦合度高。

		- 对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求
			被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部
			细节是不可见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系，耦合度低。优先
			使用对象组合有助于你保持每个类被封装。

2.基类和派生类对象赋值转换
	（1）派生类对象可以赋值给：基类的对象/基类的指针/基类的引用。这里有个形象的说法叫切片或者切割。寓意把
		派生类中父类那部分切来赋值过去。

	（2）基类对象不能赋值给派生类对象。

	（3）基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须是基类的指针是指向派生类对象时才是安全的。
		这里基类如果是多态类型，可以使用RTTI的dynamic cast来进行识别后进行安全转换。

3.继承中的作用域
	（1）在继承体系中基类和派生类都有独立的作用域。

	（2）子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。
		（在子类成员函数中，可以使用 基类::基类成员 显示访问）

	（3）需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。

	（4）注意在实际使用中，继承体系里面最好不要定义同名的成员。

4.派生类的默认成员函数
	（1）派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，
		则必须在派生类构造函数的初始化列表阶段显示调用。

	（2）派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。

	（3）派生类的operator=必须要调用基类的operator=完成基类的复制。

	（4）派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类
		对象先清理派生类成员再清理基类成员的顺序。

	（5）派生类对象初始化先调用基类构造再调派生类构造。

	（6）派生类对象析构清理先调用派生类析构再调基类的析构。

5.继承与友元
	（1）友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员。

6.继承和静态成员
	（1）基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有
		一个static成员实例。

7.继承的总结和反思
	（1）很多人说C++语法复杂，其实多继承就是一个体现。有了多继承，就存在菱形继承，有了菱形继承就有
		菱形虚拟继承，底层实现就很复杂。所以一般不建议设计出多继承，一定不要设计出菱形继承。否则
		在复杂度及性能上都有问题。

	（2）实际中尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也是有用武之地的，有些关系适合继
		承那就用继承，另外要实现多态，也必须要继承。如果类之间的关系即可以用继承，也可以用组合，
		那就用组合。




