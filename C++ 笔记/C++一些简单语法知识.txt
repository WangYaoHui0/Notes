1.C++关键字

2.命名空间
	a.命名空间可嵌套；
	b.同一工程中可以存在多个相同名称的命名空间，编译器最终会合成同一个命名空间；

	使用方法：
		-加命名空间名称及作用域限定符	N::a
		-使用 using 将命名空间中成员引入	using N::a;
		-使用 using namespace 将命名空间引入	using namespace N;

3.C++输入&输出（cin/cout）

4.缺省参数
	a.声明或定义函数时为函数的参数指定一个默认值，调用时若没有指定实参则采用默认值，否则用指定实参；
	b.半缺省参数必须从右往左依次给出，不能间隔着给；
	c.缺省参数不能在函数声明和定义中同时出现，因为如果声明与定义处同时出现，恰好两位置提供的值不同，
		编译器就无法确定到底用哪个缺省值；
	d.缺省值必须是常量或者全局变量；

5.函数重载
	a.同名函数的形参列表（参数个数 / 类型 / 顺序）必须不同；
	b.名字修饰：在编译过程中，编译器将函数通过某种算法，重新修饰为一个全局唯一的名称：
		C语言中，名字修饰规则是：在函数名字前添加下划线，
		C++中，名字修饰规则，将函数名、参数的类型、名称空间都加入了修饰后的名称中；
	c.extern "C"：有时C++工程需要将某些函数按照C的风格来编译，在函数前加 extern "C" 即可；

	常见面试题：
		-C语言中为什么不能支持函数重载？--名字修饰规则简单
		-C++中函数重载底层是怎么处理的？--通过名字修饰，将函数命修饰为全局唯一的
		-C++中能否将一个函数按照C的风格进行编译？--函数前加 extern "C"

6.引用
	a.引用就是给已存在变量取一个别名，它与它引用的变量共用同一块内存空间；
	b.类型& 引用变量名（对象名） = 引用实体; // int a = 10;	int& ra = a;
	c.引用类型必须和引用实体是同种类型的;
	d.引用的特性：
		-引用在定义时必须初始化,
		-一个变量可以有多个引用,
		-引用一旦引用一个实体，再不能引用其他实体;
	e.如果以引用类型返回，返回值的生命周期必须不受函数的限制（即比函数生命周期长）；
	f.作为函数参数，传引用比传值效率高很多； //因为传值，函数其实是传递实参或返回变量的一份临时的拷贝
	g.引用和指针在作为传参以及返回值类型上效率几乎相同；
	h.在底层实现上，引用是按照指针方式来实现的；
	i.引用与指针的不同点：
		-引用在定义时必须初始化，而指针没有要求，
		-引用初始化引用一个实体后，不可以再引用其他实体，而指针可以在任何时间指向任何一个同类型
			的实体，
		-没有NULL引用，但有NULL指针，
		-sizeof中含义不同：引用结果为引用类型的大小，指针始终是地址空间所占字节个数，
		-引用自加即引用的实体加1，指针自加即指针向后偏移一个类型的大小，
		-有多级指针，但没有多级引用，
		-访问实体时：指针需要显式解引用，引用是编译器自己处理，
		-引用比指针使用起来相对更安全；

7.内联函数
	a.以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，
		可以提升程序运行的效率；
	b.inline是以空间换时间的做法，省去调用函数的额外开销，所以代码较长或是有循环/递归的函数不宜作为
		内联函数；
	c.inline对于编译器而言仅仅是一个建议，如果定义为inline的函数体中有循环/递归等，编译器优化会忽略
		内联；
	d.inline不建议声明与定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会
		找不到；

	面试题：
		-宏的优缺点？
			优点：i.增强代码的复用性，ii.提高性能；
			缺点：i.不便于调试，ii.可读性差、可维护性差、容易误用，iii.没有类型安全的检测；
		-C++有哪些技术替代宏？
			i.常量定义 换用const；
			ii.函数定义 换用内联函数；

8.auto关键字（C++11）
	a.C++11中，auto是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导；
	b.使用auto定义变量时必须对其进行初始化，编译器在编译期根据初始化表达式推导出auto的实际类型，将
		auto替换为变量的实际类型；
	c.auto声明指针类型时，用auto和auto*没有任何区别，但auto声明引用类型时必须加&；
	d.auto在同一行声明多个变量时，这些变量必须是相同类型的，因为编译器实际只对第一个类型进行推导，
		然后用推导出的类型定义其他变量；
	e.auto不能推导的场景：
		-auto不能作为函数的参数，
		-auto不能直接用来声明数组，
		-auto不能定义类的非静态成员变量，
		-实例化模板时不能使用auto作为模板参数；

9.基于范围的for循环（C++11）
	a.范围for后的括号由冒号分为两部分：i.范围内用于迭代的变量，ii.被迭代的范围；
	b.范围for的使用条件：
		-for循环迭代的范围必须是确定的，
		-迭代的对象要实现 ++ 和 == 的操作；

10.指针空值nullptr（C++11）
	a.C++98中的指针空值NULL，在传统的C头文件(stddef.h)中，被定义为字面常量0，想要按照指针方式使用，
		必须对其进行强转；
	b.C++11中，给出nullptr表示空值指针，其类型为nullptr_t，仅可以被隐式转化为指针类型；
	c.注意：
		-使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的，
		-C++11中，sizeof(nullptr) 与 sizeof((void*)0) 所占的字节数相同，
		-为提高代码的健壮性，在后续表示指针空值时建议使用nullptr。











