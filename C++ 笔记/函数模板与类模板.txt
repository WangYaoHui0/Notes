1.泛型编程
	（1）如何实现一个通用的交换函数？
		- 使用函数重载虽然可以实现，但是有以下缺点：
			- 重载的函数仅仅只是类型不同，代码的复用率比较低，只要有新类型出现时，就需要增加对应
				的函数；
			- 代码的可维护性比较低，一个出错可能所有的重载均出错；
		- 泛型编程：
			- 编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。
			- 模板分为：函数模板、类模板。

2.函数模板
	（1）函数模板概念：
		- 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的
			特定类型版本。

	（2）函数模板格式：
		- template <typename T1, typename T2,...,typename Tn>
		- 返回值类型 函数名(参数列表){}

		- 注：typename 是用来定义模板参数关键字，也可以使用 class。(切记：不能使用struct代替class)

	（3）函数模板的原理：
		- 模板就是将本来应该我们做的重复的事情交给了编译器。
		- 在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数
			以供调用。

	（4）函数模板的实例化：
		- 用不同类型的参数使用函数模板时，称为函数模板的实例化。
		- 模板参数实例化分为：隐式实例化 和 显示实例化。
		- 隐式实例化：
			- 让编译器根据实参推演模板参数的实际类型。
		- 显示实例化：
			- 在函数名后的<>中指定模板参数的实际类型。
			- 如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。

	（5）模板参数的匹配原则：
		- 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板
			函数。
		- 对于非模板函数与同名函数模板，如果其他条件都相同，在调用时会优先调用非模板函数而不会从该
			模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数，那么将选择模板。
		- 模板函数不允许自动类型转换，但普通函数可以进行自动类型转换。

3.类模板
	（1）类模板的定义格式：
		- template <class T1, class T2, ..., class Tn>
		- class 类模板名
		- {
		- 	// 类内成员定义
		- }；
	（2）类模板的实例化：
		- 类模板实例化需要在类模板名字后面跟<>，然后将实例化的类型放在<>中即可，
		- 类模板名字不是真正的类，而实例化的结果才是真正的类。





