1.空间配置器的概念
	（1）顾名思义，就是为各个容器高效的管理空间（空间的申请和回收）的。

2.为什么需要空间配置器？
	（1）我们在前面模拟实现vector、list等等的时候，所有需要空间的地方，都是通过new去申请的，虽然代码
		正常运行，但有以下不足：
		- 空间申请与释放需要用户自己管理，容易造成内存泄漏
		- 频繁向系统申请小块内存块，容易造成内存碎片
		- 频繁向系统申请小块内存，影响程序运行效率
		- 直接使用malloc与new进行申请，每块空间前有额外空间浪费
		- 申请空间失败怎么应对
		- 代码结构比较混乱，代码复用率不高
		- 未考虑线程安全问

	（2）有以上不足，因此我们需要设计一块高效的内存管理机制。

3.SGI-STL空间配置器实现原理
	（1）上面的几点不足之中，最主要还是：频繁向系统申请小块内存造成的。那什么才算是小块内存？SGI-STL
		以128作为小块内存与大块内存的分界线，将空间配置器分为两级结构，一级空间配置器处理大块内存，
		二级空间配置器处理小块内存。

	（2）一级空间配置器：
		- 一级空间配置器原理非常简单，直接对malloc与free进行了封装，并增加了C++中set_new_handle思想。

	（3）二级空间配置器：
		- 二级空间配置器专门负责处理小于128字节的小块内存。如何才能提升小块内存的申请与释放的方式呢？
			SGISTL采用了内存池的技术来提高申请空间的速度以及减少额外空间的浪费，采用哈希桶的方式
			来提高用户获取空间的速度与高效管理。

		- 内存池：
			- 内存池就是：先申请一块比较大的内存块已做备用，当需要内存时，直接到内存池中去取，当
				池中空间不够时，再到内存中去取，当用户不用时，直接还回内存池即可。避免了频繁
				向系统申请小块内存所造成的效率低、内存碎片以及额外浪费的问题。

			- 1.当用户需要空间时，能否直接从内存池中大块空间中直接截取？为什么？
			- 2.对用户归还的空间能否直接拼接在大块内存前？
			- 3.对用户归还的空间如何进行管理？
			- 4.不断切割会有什么后果？

		- SGI-STL中二级空间配置器设计：
			- SGI-STL中的二级空间配置器使用了内存池技术，但没有采用链表的方式对用户已经归还的空间
				进行管理(因为用户申请空间时在查找合适的小块内存时效率比较低)，而是采用了哈希桶
				的方式进行管理。那是否需要128桶个空间来管理用户已经归还的内存块呢？答案是不需要，
				因为用户申请的空间基本都是4的整数倍，其他大小的空间几乎很少用到。因此：SGI-STL
				将用户申请的内存块向上对齐到了8的整数倍（那么为什么是8的整数倍，而不是4？）。

		- SGI-STL二级空间配置器之空间申请：
			- 

		- SGI-STL二级空间配置器之空间回收：
			- 

		- 空间配置器的默认选择：
			- SGI-STL默认使用一级还是二级空间配置器，通过USE_MALLOC宏进行控制
			- 在SGI_STL中该宏没有定义，因此：默认情况下SGI_STL使用二级空间配置器

		- 空间配置器的再次封装：
			- 在C++中，用户所需空间可能是任意类型的，有单个对象空间，有连续空间，每次让用户自己计算
				所需空间总大小不是很友好，因此SGI-STL将空间配置器重新再封装了一层。

		- 对象的构造与释放：
			- 一切为了效率考虑，SGI-STL决定将空间申请释放和对象的构造析构两个过程分离开，因为有些对象
				的构造不需要调用构造函数，销毁时不需要调用析构函数，将该过程分离开可以提高程序的性能。

			- 注：
				- 1.在释放对象时，需要根据对象的类型确定是否调用析构函数(类型萃取)
				- 2.对象的类型可以通过迭代器获取到


