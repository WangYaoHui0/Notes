1.初始化与隐式转换
	（1）构造函数体赋值：
		-构造函数调用之后，对象中已经有一个初始值，但不能将其称为类对象成员的初始化，构造函数体中的
			语句只能将其称为赋初值，因为初始化只能初始化一次，而构造函数体内可以多次赋值；
	（2）初始化列表：
		-以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个“成员变量”后跟一个放在括号中的
			初始值或表达式；
		注意：
			-每个成员变量在初始化列表中只能出现一次（初始化只能初始化一次），
			-类中包含以下成员，必须放在初始化列表位置进行初始化：
				引用成员变量、
				const成员变量、
				类类型成员（该类没有默认构造函数），
			-尽量使用初始化列表进行初始化，因为对于自定义类型成员变量，不管你是否使用初始化列表，
				都一定会先使用初始化列表初始化，
			-成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后
				次序无关；
	（3）explicit关键字
		-构造函数不仅可以构造与初始化对象，对于单个参数的构造函数，还具有类型转换的作用；
		-用explicit修饰构造函数，将会禁止单参构造函数的隐式转换；

2.static成员
	（1）概念：声明为static的类成员称为类的静态成员。静态的成员变量一定要在类外进行初始化；
		-面试题：实现一个类，计算程序中创建出了多少个类对象？
	（2）特性：
		-静态成员为所有类对象所共享，不属于某个具体的实例，
		-静态成员变量必须在类外定义，定义时不添加static关键字，
		-类静态成员即可用 （类名::静态成员） 或者 （对象.静态成员） 来访问，
		-静态成员函数没有隐藏的this指针，不能访问任何非静态成员，
		-静态成员和类的普通成员一样，也有public、protected、private三种访问级别，也可以具有返回值、
			const修饰符等参数；

	-面试题：
		-静态成员函数可以调用非静态成员函数吗？----不可以
		-非静态成员函数可以调用类的静态成员函数吗？----可以

3.C++11的成员初始化新玩法
	（1）C++11支持非静态成员变量在声明时，直接初始化；

4.再次理解封装
	（1）C++通过类，将一个对象的属性和行为结合在一起，使其更符合人们对于一件事物的认知，将属于该对象的所有
		东西打包在一起，通过访问限定符选择性的将其部分功能开放出来与其他对象进行交互，而对于对象内部的
		一些实现细节，外部用户不需要知道，知道了有些情况下也没用，反而会增加使用或者维护的难度。


























