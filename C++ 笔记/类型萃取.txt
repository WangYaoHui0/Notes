1.类模板特化的应用：类型萃取
	（1）问：如何实现一个通用的拷贝函数？
		- 1.使用memcpy拷贝
			- memcpy虽然对于任意类型的空间都可以进行拷贝，但是如果拷贝自定义类型对象就可能会出错，
				因为自定义类型对象有可能会涉及到深拷贝(比如string)，而memcpy属于浅拷贝。

			- 因此，如果对象中涉及到资源管理，就只能用赋值。

		- 2.使用赋值方式拷贝
			- 用循环赋值的方式虽然可以，但是代码的效率比较低，而 C/C++ 程序最大的优势就是效率高。

			- 那能否将两种方式的优势结合起来呢？遇到内置类型就用memcpy来拷贝，遇到自定义类型就用
				循环赋值方式来做呢？

		- 3.增加bool类型区分自定义与内置类型
			- 通过多增加一个参数，就可将两种拷贝的优势体现结合起来。

			- 但缺陷是：用户需要根据所拷贝元素的类型去传递第三个参数，那出错的可能性就会增加。
			- 那能否让函数自动去识别所拷贝类型是内置类型或者自定义类型呢？

		- 4.使用函数区分内置与自定义类型
			- 因为内置类型的个数是确定的，可以将所有内置类型集合在一起，
			- 如果能够将所拷贝对象的类型确定下来，在内置类型集合中查找其是否存在即可确定所拷贝类型
				是否为内置类型。
			- 通过typeid来确认所拷贝对象的实际类型，然后再在内置类型集合中枚举其是否出现过，既可确认
				所拷贝元素的类型为内置类型或者自定义类型。

			- 但缺陷是：枚举需要将所有类型遍历一遍，每次比较都是字符串的比较，效率比较低。

		- 5.类型萃取
			- 为了将内置类型与自定义类型区分开，给出两个类分别代表内置类型与自定义类型，
			- 给出TypeTraits类模板，将来用户可以按照任意类型实例化该类模板，
			- 对TypeTraits类模板，将所有内置类型逐一特化，即可保证内置类型使用memcpy方式拷贝，
				自定义类型使用赋值方式拷贝。

		- 6.STL中的类型萃取例子



